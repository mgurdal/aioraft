{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIORAFT","title":"Home"},{"location":"#aioraft","text":"","title":"AIORAFT"},{"location":"terminology/","text":"RAFT RAFT, sunucular aras\u0131nda uzla\u015fma(concensus) sa\u011flayan bir algoritmad\u0131r. RAFT sayesinde da\u011f\u0131t\u0131k bir sistem, sunucular\u0131n yar\u0131s\u0131ndan fazlas\u0131 ayakta kald\u0131\u011f\u0131 s\u00fcrece, normal bir \u015fekilde hizmet verebilir. Uzla\u015fma(Consensus) Da\u011f\u0131t\u0131k bir sistemde, t\u00fcm sunucular\u0131n ayn\u0131 verilere sahip oldu\u011fundan emin olmas\u0131d\u0131r. Uzla\u015fma algoritmalar\u0131 sunucular\u0131n \u00e7o\u011funlu\u011fu hizmet verebildi\u011fi s\u00fcrece ilerlemeye devam edebilir. \u00d6rne\u011fin; 5 sunucuya sahip bir sistem, sunucular\u0131n 2si \u00e7\u00f6kse dahi normal bir \u015fekilde hizmet verebilir. Uzla\u015fma algoritmalar\u0131n\u0131n hataya t\u00f6lere \u015fekilde \u00e7al\u0131\u015fmas\u0131 genellikle \u00e7o\u011falt\u0131lm\u0131\u015f durum makineleri( replicated state machine ) ile sa\u011flan\u0131r. \u00c7o\u011falt\u0131lm\u0131\u015f durum makinelerinde, her sunucunun bir durum makinesi ve makineye gelen komutlar\u0131 kaydetti\u011fi bir logu olur. Buradaki ama\u00e7 durum makinesini hataya t\u00f6lere etmektir. Hata t\u00f6lerans\u0131 (fault-tolerance) : Sistemin, baz\u0131 par\u00e7alar\u0131 hata verse bile d\u00fczg\u00fcn bir \u015fekilde hizmet verebilmesidir. Durum makineleri ve komut kay\u0131tlar\u0131 RAFT gibi bir sistemle \u00e7o\u011falt\u0131larak istemciye( client ) g\u00fcvenli tek bir durum makinesinde komut \u00e7al\u0131\u015ft\u0131r\u0131l\u0131yormu\u015f gibi g\u00f6sterilebilir. \u00d6rnek Sistemin \u00e7al\u0131\u015fma yap\u0131s\u0131n\u0131 bir \u00f6rnekle a\u00e7\u0131klayal\u0131m. Elimizde sisteme veri ekleyebildi\u011fimiz bir durum makinesi olsun. Client bu durum makinesine bir key ile veri ekleme( add ) komutu g\u00f6nderebilir. state_machine = StateMachine () state_machine . apply ( add , total , 2020 ) Bu durum makinesini \u00e7o\u011falt\u0131\u011f\u0131m\u0131z zaman birbirleri ile her zaman senkronize olmas\u0131n\u0131 sa\u011flamam\u0131z gerekiyor. Bunun i\u00e7in durum makinelerine bir komut geldi\u011finde; \u00f6nce bu komutu kal\u0131c\u0131 bir \u015fekilde sunucuda depolamal\u0131, ard\u0131ndan komutu di\u011fer durum makinelerine da\u011f\u0131tmal\u0131 ve bunun sonunda t\u00fcm durum makinelerinde komutu \u00e7al\u0131\u015ft\u0131rmal\u0131y\u0131z. B\u00fct\u00fcn sunucular her zaman ayn\u0131 durum makinesine ve loga sahip olaca\u011f\u0131 i\u00e7in, herhangi bir zamanda lider(istek alan sunucu) \u00e7\u00f6kerse kalan 2 sunucudan birisini lider olarak se\u00e7ebiliriz. Google File System, HDFS, RAMCloud gibi large-scale sistemler olas\u0131 sunucu \u00e7\u00f6kmelerinde sistemi ayakta tutabilmek i\u00e7in; \u00e7o\u011falt\u0131lm\u0131\u015f durum makinelerini kullanarak lider se\u00e7imlerini y\u00f6netmekte ve konfig\u00fcrasyon bilgilerini kaydetmektedir. RAFT Uzla\u015fma Mekanizmas\u0131 Bir istemci lider sunucuya komut g\u00f6nderdi\u011finde, lider bu komutu kendi ve di\u011fer takip\u00e7i sunucular\u0131n loglar\u0131na ekler ve komutun \u00e7al\u0131\u015ft\u0131r\u0131lmaya uygun oldu\u011funa karar verdi\u011finde t\u00fcm sunucular\u0131n durum makinelerine g\u00f6nderir. Sunucu Rolleri RAFT algoritmas\u0131nda uzla\u015fma a\u015famas\u0131 \u00f6ncelikle bir Lider( Leader ) se\u00e7ilerek ba\u015flar. Se\u00e7ilen lider \u00e7o\u011falt\u0131lm\u0131\u015f loglar\u0131n y\u00f6netilmesinden sorumludur. Sistemde b\u00fct\u00fcn sunucular Takip\u00e7i( Follower ) durumunda ba\u015flar. Liderden bir s\u00fcre mesaj alamad\u0131\u011f\u0131 zaman takip\u00e7iler Aday( Candidate ) durumuna ge\u00e7er ve se\u00e7im ba\u015flat\u0131rlar. Oy \u00e7o\u011funlu\u011funa sahip aday sunucu Lider olur ve di\u011fer sunuculara ya\u015fam( heartbeat ) mesajlar\u0131 g\u00f6ndererek liderli\u011fini belirtir. Liderden mesaj alan Aday sunucular Takip\u00e7i durumuna geri d\u00f6nerler. Liderin \u00e7\u00f6kt\u00fc\u011f\u00fc ve yeni bir liderin se\u00e7ildi\u011fi durumda e\u011fer eski lider yeniden aya\u011fa kalkarsa, sistemde kar\u0131\u015f\u0131kl\u0131k olmamas\u0131 i\u00e7in RAFT eski lideri bilgilendirir ve takip\u00e7i durumuna d\u00f6nd\u00fcr\u00fcr. \u00c7al\u0131\u015fma D\u00f6nemleri Sunucular\u0131n durumlar\u0131n\u0131 kontrol alt\u0131nda tutmak i\u00e7in RAFT zaman\u0131 d\u00f6nemlere( term ) b\u00f6ler. D\u00f6nemler artan say\u0131lar \u015feklinde belirlenir. D\u00f6nemler se\u00e7imlerle birlikte de\u011fi\u015fir ve lider se\u00e7ildi\u011fi d\u00f6nem boyunca liderli\u011fine devam eder. Se\u00e7imlerde birden fazla sunucu en fazla oyu al\u0131rsa o d\u00f6nem lider se\u00e7ilmeden biter ve yeniden se\u00e7im ba\u015flat\u0131larak yeni bir d\u00f6neme ge\u00e7ilir. Her sunucu o anki d\u00f6nemini kay\u0131tl\u0131 tutar ve bir sunucuyla haberle\u015firken payla\u015f\u0131r. E\u011fer bir sunucu daha yeni bir d\u00f6nem numaras\u0131na sahip mesaj al\u0131rsa kendini yeni d\u00f6nemle g\u00fcnceller. E\u011fer bu sunucu Aday veya Liderse do\u011frudan Takip\u00e7i durumuna ge\u00e7er. E\u011fer eski bir d\u00f6neme ait mesaj al\u0131n\u0131rsa bu mesaj reddedilir. Rollerin G\u00f6revleri Ortak G\u00f6revler T\u00fcm sunucular; Yeni bir log commit edilmi\u015fse bir sonraki komutu durum makinesinde \u00e7al\u0131\u015ft\u0131r\u0131r. RPC iste\u011finde veya cevab\u0131ndaki d\u00f6nem de\u011feri sunucunun d\u00f6neminden b\u00fcy\u00fckse, sunucu d\u00f6nemini g\u00fcnceller ve Follower durumuna ge\u00e7er. Follower Liderden ve Adaylardan gelen t\u00fcm RPClere cevap verir. Beklenen s\u00fcre i\u00e7erisinde Liderden AppendEntries iste\u011fi gelmezse veya bir sunucuya oy vermezse Aday konumuna ge\u00e7er. Candidate Aday konumuna ge\u00e7ildi\u011finde se\u00e7im ba\u015flat\u0131r. G\u00fcncel d\u00f6nemi bir art\u0131r\u0131r. Kendine oy verir. Se\u00e7im sayac\u0131n\u0131 resetler. Di\u011fer t\u00fcm sunuculara RequestVote g\u00f6ndererek oy ister. Sunucular\u0131n \u00e7o\u011fundan oy al\u0131rsa Lider konumuna ge\u00e7er. E\u011fer yeni Liderden AppendEntries mesaj\u0131 gelirse Takip\u00e7i konumuna ge\u00e7er. E\u011fer se\u00e7im sayac\u0131 biterse; yeni se\u00e7im ba\u015flat\u0131r. Leader Se\u00e7im s\u00fcresinde her bir sunucuya bo\u015f AppendEntries(heartbeat) mesaj\u0131 g\u00f6nderir ve bunu yeni bir se\u00e7imin ba\u015flamamas\u0131 i\u00e7in k\u0131sa aral\u0131klarla s\u00fcrekli tekrar eder. \u0130stemciden komut gelirse; kendi loguna kayd\u0131n\u0131 ekler. Durum makinesine komut uyguland\u0131ktan sonra istemciye cevap verir. Loglara yeni kay\u0131t eklenmi\u015fse, her takip\u00e7iye b\u00fct\u00fcn yeni kay\u0131tlar\u0131 g\u00f6nderir. Ba\u015far\u0131l\u0131 bir \u015fekilde Takip\u00e7iye kay\u0131tlar eklenirse; Takip\u00e7inin indeks bilgilerini g\u00fcnceller. Kay\u0131tlar eklenemezse; Log kay\u0131tlar\u0131 uyu\u015fmad\u0131\u011f\u0131 i\u00e7in kay\u0131tlar olu\u015fturulamam\u0131\u015ft\u0131r. Takip\u00e7inin bilinen indeks de\u011ferini bir azalt ve tekrar dene. Bu i\u015flem sayesinde Takip\u00e7inin uyu\u015fan en son kayd\u0131na kadar gidilip o kay\u0131ttan itibaren t\u00fcm uyu\u015fmayan kay\u0131tlar\u0131 liderin kay\u0131tlar\u0131yla de\u011fi\u015ftirilir. Kendi loglar\u0131nda son commitlenen indeksten daha b\u00fcy\u00fck bir indeks varsa ve Takip\u00e7ilerin \u00e7o\u011funda bu indekse sahip g\u00fcncel bir kay\u0131t varsa commit indeksini bu indeks ile g\u00fcnceller. Haberle\u015fme RAFT sunucular\u0131 RPC protokol\u00fc ile haberle\u015fir ve temel uzla\u015f\u0131m algoritmas\u0131n\u0131 kurgulamak i\u00e7in sadece 2 t\u00fcr RPC mesaj\u0131 yeterlidir. RequestVote adaylar taraf\u0131ndan, se\u00e7im s\u0131ras\u0131nda di\u011fer sunuculardan oy istemek i\u00e7in kullan\u0131l\u0131r. message RequestVote { // Adaya ait d\u00f6nem numaras\u0131 int32 term = 1 ; // Aday numaras\u0131 int32 candidateId = 2 ; // Aday\u0131n en son loglad\u0131\u011f\u0131 komutun indexi int32 lastLogIndex = 3 ; // Aday\u0131n en son loglad\u0131\u011f\u0131 komutun d\u00f6nemi int32 lastLogTerm = 4 ; } message RequestVoteReply { // Oy istenen sunucunun d\u00f6nem numaras\u0131 int32 term = 1 ; // Aday oy almas\u0131 durumunda True olur bool voteGranted = 2 ; } AppendEntries lider taraf\u0131ndan log payla\u015fmak ve di\u011fer sunuculara lider oldu\u011funu belirtmek i\u00e7in kullan\u0131l\u0131r. message Entry { // Log kayd\u0131n\u0131n girildi\u011fi d\u00f6nem int32 term = 1 ; // Loglanan komut int32 command = 2 ; } message AppendEntries { // Lidere ait d\u00f6nem numaras\u0131 int32 term = 1 ; // Liderin idsi, takip\u00e7iye gelen ba\u011flant\u0131y\u0131 lidere y\u00f6nlendirmek i\u00e7in int32 leaderId = 2 ; // Yeni kay\u0131tlardan \u00f6nceki son kayd\u0131n indeksi int32 prevLogIndex = 3 ; // prevLogIndexdeki kayd\u0131n d\u00f6nem numaras\u0131 int32 prevLogTerm = 4 ; // Kaydedilecek log girdileri. Heartbeat mesajlar\u0131 i\u00e7in bo\u015f g\u00f6nderilir. repeated Entry entries = 5 ; // Liderin commitledi\u011fi son kayd\u0131n indeksi. int32 leaderCommit = 6 ; } message AppendEntriesReply { // Takip\u00e7inin o anki g\u00fcncel d\u00f6nemi int32 term = 1 ; // E\u011fer ba\u015far\u0131l\u0131 bir \u015fekilde kay\u0131tlar eklendiyse //(prevLogIndex ve prevLogTerm de\u011ferleri e\u015fle\u015fiyorsa) True bool success = 2 ; } Sunucularda Saklanan Bilgiler RAFT sunucular\u0131nda tutulan bilgileri 3 kategoriye ay\u0131rabiliriz. T\u00fcm Sunucularda Kal\u0131c\u0131 Olarak Saklanan Bilgiler Bu bilgiler, her RPC cevab\u0131ndan \u00f6nce sabit diskte g\u00fcncellenir. currentTerm : Sunucunun en g\u00fcncel d\u00f6nemi. 0 dan ba\u015flay\u0131p monoton olarak artar. votedFor : D\u00f6nem i\u00e7in sunucunun oy verdi\u011fi Aday\u0131n idsi. log[] : Komut kay\u0131tlar\u0131. Durum makinesinde i\u00e7in olu\u015fturulan komutlar\u0131 ve komutlar\u0131 kaydeden liderin d\u00f6nemini i\u00e7erir. T\u00fcm Sunucularda De\u011fi\u015fken Bilgiler commitIndex : Bilinen en son commit edilmi\u015f log kayd\u0131n\u0131n indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar. lastApplied : En son uygulanan komutun log indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar. Lidere \u00d6zg\u00fc Bilgiler Bu bilgiler her se\u00e7imden sonra yeniden tan\u0131mlan\u0131r. nextIndex[] : Her sunucunun bir sonraki kayd\u0131 tutaca\u011f\u0131 log indeksi. matchIndex[] : Her sunucunun kopyas\u0131n\u0131 tutaca\u011f\u0131 bilinen en sonuncu kayd\u0131n indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar. class State : log : List [ Entry ] currentTerm : int votedFor : int commitIndex : int lastApplied : int ... class Leader ( State ): nextIndex : List [ int ] matchIndex : List [ int ] ... class Candidate ( State ): ... class Follower ( State ): ...","title":"What is RAFT"},{"location":"terminology/#raft","text":"RAFT, sunucular aras\u0131nda uzla\u015fma(concensus) sa\u011flayan bir algoritmad\u0131r. RAFT sayesinde da\u011f\u0131t\u0131k bir sistem, sunucular\u0131n yar\u0131s\u0131ndan fazlas\u0131 ayakta kald\u0131\u011f\u0131 s\u00fcrece, normal bir \u015fekilde hizmet verebilir.","title":"RAFT"},{"location":"terminology/#uzlasmaconsensus","text":"Da\u011f\u0131t\u0131k bir sistemde, t\u00fcm sunucular\u0131n ayn\u0131 verilere sahip oldu\u011fundan emin olmas\u0131d\u0131r. Uzla\u015fma algoritmalar\u0131 sunucular\u0131n \u00e7o\u011funlu\u011fu hizmet verebildi\u011fi s\u00fcrece ilerlemeye devam edebilir. \u00d6rne\u011fin; 5 sunucuya sahip bir sistem, sunucular\u0131n 2si \u00e7\u00f6kse dahi normal bir \u015fekilde hizmet verebilir. Uzla\u015fma algoritmalar\u0131n\u0131n hataya t\u00f6lere \u015fekilde \u00e7al\u0131\u015fmas\u0131 genellikle \u00e7o\u011falt\u0131lm\u0131\u015f durum makineleri( replicated state machine ) ile sa\u011flan\u0131r. \u00c7o\u011falt\u0131lm\u0131\u015f durum makinelerinde, her sunucunun bir durum makinesi ve makineye gelen komutlar\u0131 kaydetti\u011fi bir logu olur. Buradaki ama\u00e7 durum makinesini hataya t\u00f6lere etmektir. Hata t\u00f6lerans\u0131 (fault-tolerance) : Sistemin, baz\u0131 par\u00e7alar\u0131 hata verse bile d\u00fczg\u00fcn bir \u015fekilde hizmet verebilmesidir. Durum makineleri ve komut kay\u0131tlar\u0131 RAFT gibi bir sistemle \u00e7o\u011falt\u0131larak istemciye( client ) g\u00fcvenli tek bir durum makinesinde komut \u00e7al\u0131\u015ft\u0131r\u0131l\u0131yormu\u015f gibi g\u00f6sterilebilir.","title":"Uzla\u015fma(Consensus)"},{"location":"terminology/#ornek","text":"Sistemin \u00e7al\u0131\u015fma yap\u0131s\u0131n\u0131 bir \u00f6rnekle a\u00e7\u0131klayal\u0131m. Elimizde sisteme veri ekleyebildi\u011fimiz bir durum makinesi olsun. Client bu durum makinesine bir key ile veri ekleme( add ) komutu g\u00f6nderebilir. state_machine = StateMachine () state_machine . apply ( add , total , 2020 ) Bu durum makinesini \u00e7o\u011falt\u0131\u011f\u0131m\u0131z zaman birbirleri ile her zaman senkronize olmas\u0131n\u0131 sa\u011flamam\u0131z gerekiyor. Bunun i\u00e7in durum makinelerine bir komut geldi\u011finde; \u00f6nce bu komutu kal\u0131c\u0131 bir \u015fekilde sunucuda depolamal\u0131, ard\u0131ndan komutu di\u011fer durum makinelerine da\u011f\u0131tmal\u0131 ve bunun sonunda t\u00fcm durum makinelerinde komutu \u00e7al\u0131\u015ft\u0131rmal\u0131y\u0131z. B\u00fct\u00fcn sunucular her zaman ayn\u0131 durum makinesine ve loga sahip olaca\u011f\u0131 i\u00e7in, herhangi bir zamanda lider(istek alan sunucu) \u00e7\u00f6kerse kalan 2 sunucudan birisini lider olarak se\u00e7ebiliriz. Google File System, HDFS, RAMCloud gibi large-scale sistemler olas\u0131 sunucu \u00e7\u00f6kmelerinde sistemi ayakta tutabilmek i\u00e7in; \u00e7o\u011falt\u0131lm\u0131\u015f durum makinelerini kullanarak lider se\u00e7imlerini y\u00f6netmekte ve konfig\u00fcrasyon bilgilerini kaydetmektedir.","title":"\u00d6rnek"},{"location":"terminology/#raft-uzlasma-mekanizmas","text":"Bir istemci lider sunucuya komut g\u00f6nderdi\u011finde, lider bu komutu kendi ve di\u011fer takip\u00e7i sunucular\u0131n loglar\u0131na ekler ve komutun \u00e7al\u0131\u015ft\u0131r\u0131lmaya uygun oldu\u011funa karar verdi\u011finde t\u00fcm sunucular\u0131n durum makinelerine g\u00f6nderir.","title":"RAFT Uzla\u015fma Mekanizmas\u0131"},{"location":"terminology/#sunucu-rolleri","text":"RAFT algoritmas\u0131nda uzla\u015fma a\u015famas\u0131 \u00f6ncelikle bir Lider( Leader ) se\u00e7ilerek ba\u015flar. Se\u00e7ilen lider \u00e7o\u011falt\u0131lm\u0131\u015f loglar\u0131n y\u00f6netilmesinden sorumludur. Sistemde b\u00fct\u00fcn sunucular Takip\u00e7i( Follower ) durumunda ba\u015flar. Liderden bir s\u00fcre mesaj alamad\u0131\u011f\u0131 zaman takip\u00e7iler Aday( Candidate ) durumuna ge\u00e7er ve se\u00e7im ba\u015flat\u0131rlar. Oy \u00e7o\u011funlu\u011funa sahip aday sunucu Lider olur ve di\u011fer sunuculara ya\u015fam( heartbeat ) mesajlar\u0131 g\u00f6ndererek liderli\u011fini belirtir. Liderden mesaj alan Aday sunucular Takip\u00e7i durumuna geri d\u00f6nerler. Liderin \u00e7\u00f6kt\u00fc\u011f\u00fc ve yeni bir liderin se\u00e7ildi\u011fi durumda e\u011fer eski lider yeniden aya\u011fa kalkarsa, sistemde kar\u0131\u015f\u0131kl\u0131k olmamas\u0131 i\u00e7in RAFT eski lideri bilgilendirir ve takip\u00e7i durumuna d\u00f6nd\u00fcr\u00fcr.","title":"Sunucu Rolleri"},{"location":"terminology/#calsma-donemleri","text":"Sunucular\u0131n durumlar\u0131n\u0131 kontrol alt\u0131nda tutmak i\u00e7in RAFT zaman\u0131 d\u00f6nemlere( term ) b\u00f6ler. D\u00f6nemler artan say\u0131lar \u015feklinde belirlenir. D\u00f6nemler se\u00e7imlerle birlikte de\u011fi\u015fir ve lider se\u00e7ildi\u011fi d\u00f6nem boyunca liderli\u011fine devam eder. Se\u00e7imlerde birden fazla sunucu en fazla oyu al\u0131rsa o d\u00f6nem lider se\u00e7ilmeden biter ve yeniden se\u00e7im ba\u015flat\u0131larak yeni bir d\u00f6neme ge\u00e7ilir. Her sunucu o anki d\u00f6nemini kay\u0131tl\u0131 tutar ve bir sunucuyla haberle\u015firken payla\u015f\u0131r. E\u011fer bir sunucu daha yeni bir d\u00f6nem numaras\u0131na sahip mesaj al\u0131rsa kendini yeni d\u00f6nemle g\u00fcnceller. E\u011fer bu sunucu Aday veya Liderse do\u011frudan Takip\u00e7i durumuna ge\u00e7er. E\u011fer eski bir d\u00f6neme ait mesaj al\u0131n\u0131rsa bu mesaj reddedilir.","title":"\u00c7al\u0131\u015fma D\u00f6nemleri"},{"location":"terminology/#rollerin-gorevleri","text":"","title":"Rollerin G\u00f6revleri"},{"location":"terminology/#ortak-gorevler","text":"T\u00fcm sunucular; Yeni bir log commit edilmi\u015fse bir sonraki komutu durum makinesinde \u00e7al\u0131\u015ft\u0131r\u0131r. RPC iste\u011finde veya cevab\u0131ndaki d\u00f6nem de\u011feri sunucunun d\u00f6neminden b\u00fcy\u00fckse, sunucu d\u00f6nemini g\u00fcnceller ve Follower durumuna ge\u00e7er.","title":"Ortak G\u00f6revler"},{"location":"terminology/#follower","text":"Liderden ve Adaylardan gelen t\u00fcm RPClere cevap verir. Beklenen s\u00fcre i\u00e7erisinde Liderden AppendEntries iste\u011fi gelmezse veya bir sunucuya oy vermezse Aday konumuna ge\u00e7er.","title":"Follower"},{"location":"terminology/#candidate","text":"Aday konumuna ge\u00e7ildi\u011finde se\u00e7im ba\u015flat\u0131r. G\u00fcncel d\u00f6nemi bir art\u0131r\u0131r. Kendine oy verir. Se\u00e7im sayac\u0131n\u0131 resetler. Di\u011fer t\u00fcm sunuculara RequestVote g\u00f6ndererek oy ister. Sunucular\u0131n \u00e7o\u011fundan oy al\u0131rsa Lider konumuna ge\u00e7er. E\u011fer yeni Liderden AppendEntries mesaj\u0131 gelirse Takip\u00e7i konumuna ge\u00e7er. E\u011fer se\u00e7im sayac\u0131 biterse; yeni se\u00e7im ba\u015flat\u0131r.","title":"Candidate"},{"location":"terminology/#leader","text":"Se\u00e7im s\u00fcresinde her bir sunucuya bo\u015f AppendEntries(heartbeat) mesaj\u0131 g\u00f6nderir ve bunu yeni bir se\u00e7imin ba\u015flamamas\u0131 i\u00e7in k\u0131sa aral\u0131klarla s\u00fcrekli tekrar eder. \u0130stemciden komut gelirse; kendi loguna kayd\u0131n\u0131 ekler. Durum makinesine komut uyguland\u0131ktan sonra istemciye cevap verir. Loglara yeni kay\u0131t eklenmi\u015fse, her takip\u00e7iye b\u00fct\u00fcn yeni kay\u0131tlar\u0131 g\u00f6nderir. Ba\u015far\u0131l\u0131 bir \u015fekilde Takip\u00e7iye kay\u0131tlar eklenirse; Takip\u00e7inin indeks bilgilerini g\u00fcnceller. Kay\u0131tlar eklenemezse; Log kay\u0131tlar\u0131 uyu\u015fmad\u0131\u011f\u0131 i\u00e7in kay\u0131tlar olu\u015fturulamam\u0131\u015ft\u0131r. Takip\u00e7inin bilinen indeks de\u011ferini bir azalt ve tekrar dene. Bu i\u015flem sayesinde Takip\u00e7inin uyu\u015fan en son kayd\u0131na kadar gidilip o kay\u0131ttan itibaren t\u00fcm uyu\u015fmayan kay\u0131tlar\u0131 liderin kay\u0131tlar\u0131yla de\u011fi\u015ftirilir. Kendi loglar\u0131nda son commitlenen indeksten daha b\u00fcy\u00fck bir indeks varsa ve Takip\u00e7ilerin \u00e7o\u011funda bu indekse sahip g\u00fcncel bir kay\u0131t varsa commit indeksini bu indeks ile g\u00fcnceller.","title":"Leader"},{"location":"terminology/#haberlesme","text":"RAFT sunucular\u0131 RPC protokol\u00fc ile haberle\u015fir ve temel uzla\u015f\u0131m algoritmas\u0131n\u0131 kurgulamak i\u00e7in sadece 2 t\u00fcr RPC mesaj\u0131 yeterlidir. RequestVote adaylar taraf\u0131ndan, se\u00e7im s\u0131ras\u0131nda di\u011fer sunuculardan oy istemek i\u00e7in kullan\u0131l\u0131r. message RequestVote { // Adaya ait d\u00f6nem numaras\u0131 int32 term = 1 ; // Aday numaras\u0131 int32 candidateId = 2 ; // Aday\u0131n en son loglad\u0131\u011f\u0131 komutun indexi int32 lastLogIndex = 3 ; // Aday\u0131n en son loglad\u0131\u011f\u0131 komutun d\u00f6nemi int32 lastLogTerm = 4 ; } message RequestVoteReply { // Oy istenen sunucunun d\u00f6nem numaras\u0131 int32 term = 1 ; // Aday oy almas\u0131 durumunda True olur bool voteGranted = 2 ; } AppendEntries lider taraf\u0131ndan log payla\u015fmak ve di\u011fer sunuculara lider oldu\u011funu belirtmek i\u00e7in kullan\u0131l\u0131r. message Entry { // Log kayd\u0131n\u0131n girildi\u011fi d\u00f6nem int32 term = 1 ; // Loglanan komut int32 command = 2 ; } message AppendEntries { // Lidere ait d\u00f6nem numaras\u0131 int32 term = 1 ; // Liderin idsi, takip\u00e7iye gelen ba\u011flant\u0131y\u0131 lidere y\u00f6nlendirmek i\u00e7in int32 leaderId = 2 ; // Yeni kay\u0131tlardan \u00f6nceki son kayd\u0131n indeksi int32 prevLogIndex = 3 ; // prevLogIndexdeki kayd\u0131n d\u00f6nem numaras\u0131 int32 prevLogTerm = 4 ; // Kaydedilecek log girdileri. Heartbeat mesajlar\u0131 i\u00e7in bo\u015f g\u00f6nderilir. repeated Entry entries = 5 ; // Liderin commitledi\u011fi son kayd\u0131n indeksi. int32 leaderCommit = 6 ; } message AppendEntriesReply { // Takip\u00e7inin o anki g\u00fcncel d\u00f6nemi int32 term = 1 ; // E\u011fer ba\u015far\u0131l\u0131 bir \u015fekilde kay\u0131tlar eklendiyse //(prevLogIndex ve prevLogTerm de\u011ferleri e\u015fle\u015fiyorsa) True bool success = 2 ; }","title":"Haberle\u015fme"},{"location":"terminology/#sunucularda-saklanan-bilgiler","text":"RAFT sunucular\u0131nda tutulan bilgileri 3 kategoriye ay\u0131rabiliriz.","title":"Sunucularda Saklanan Bilgiler"},{"location":"terminology/#tum-sunucularda-kalc-olarak-saklanan-bilgiler","text":"Bu bilgiler, her RPC cevab\u0131ndan \u00f6nce sabit diskte g\u00fcncellenir. currentTerm : Sunucunun en g\u00fcncel d\u00f6nemi. 0 dan ba\u015flay\u0131p monoton olarak artar. votedFor : D\u00f6nem i\u00e7in sunucunun oy verdi\u011fi Aday\u0131n idsi. log[] : Komut kay\u0131tlar\u0131. Durum makinesinde i\u00e7in olu\u015fturulan komutlar\u0131 ve komutlar\u0131 kaydeden liderin d\u00f6nemini i\u00e7erir.","title":"T\u00fcm Sunucularda Kal\u0131c\u0131 Olarak Saklanan Bilgiler"},{"location":"terminology/#tum-sunucularda-degisken-bilgiler","text":"commitIndex : Bilinen en son commit edilmi\u015f log kayd\u0131n\u0131n indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar. lastApplied : En son uygulanan komutun log indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar.","title":"T\u00fcm Sunucularda De\u011fi\u015fken Bilgiler"},{"location":"terminology/#lidere-ozgu-bilgiler","text":"Bu bilgiler her se\u00e7imden sonra yeniden tan\u0131mlan\u0131r. nextIndex[] : Her sunucunun bir sonraki kayd\u0131 tutaca\u011f\u0131 log indeksi. matchIndex[] : Her sunucunun kopyas\u0131n\u0131 tutaca\u011f\u0131 bilinen en sonuncu kayd\u0131n indeksi. 0 dan ba\u015flay\u0131p monoton olarak artar. class State : log : List [ Entry ] currentTerm : int votedFor : int commitIndex : int lastApplied : int ... class Leader ( State ): nextIndex : List [ int ] matchIndex : List [ int ] ... class Candidate ( State ): ... class Follower ( State ): ...","title":"Lidere \u00d6zg\u00fc Bilgiler"}]}